<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using Funq.Collections.Implementation.Common;
using System;
namespace Funq.Collections.Implementation {
	static partial class FingerTree<TValue> {
		abstract partial class FTree<TChild> {
			internal sealed partial class Digit {
					public FingerTree<TValue2>.FTree<TInner>.Digit ApplyTo<TInner, TValue2>(int nesting, Func<TValue, TValue2> f,
						Lineage lin) where TInner : FingerTree<TValue2>.Measured<TInner>, new() {
					var nextNesting = nesting - 1;
					switch (Size) {
						case 1:
							return new FingerTree<TValue2>.FTree<TInner>.Digit(First.Apply<TInner, TValue2>(nextNesting, f, lin), lin);
						case 2:
							return new FingerTree<TValue2>.FTree<TInner>.Digit(First.Apply<TInner, TValue2>(nextNesting, f, lin),
								Second.Apply<TInner, TValue2>(nextNesting, f, lin), lin);
						case 3:
							return new FingerTree<TValue2>.FTree<TInner>.Digit(First.Apply<TInner, TValue2>(nextNesting, f, lin),
								Second.Apply<TInner, TValue2>(nextNesting, f, lin), Third.Apply<TInner, TValue2>(nextNesting, f, lin), lin);
						case 4:
							return new FingerTree<TValue2>.FTree<TInner>.Digit(
								First.Apply<TInner, TValue2>(nesting - 1, f, lin),
								Second.Apply<TInner, TValue2>(nesting - 1, f, lin),
								Third.Apply<TInner, TValue2>(nesting - 1, f, lin),
								Fourth.Apply<TInner, TValue2>(nesting - 1, f, lin),
								lin
								);
						default:
							throw ImplErrors.Bad_digit_size(Size);
					}
				}

				///<summary>
				///A kind of hack. Applies the 'selector' over each element in the digit, returning a new digit containing leaf values of the type 'TValue2'.<br/>
				///</summary>
				///<remarks>
				///To explain what this method really does and what it's for, you have to note that it's not possible to link the types of two digits that are structurally at the same level,
				///but have different leaf values.  So there is no way to meaningfuly encode the return type of this method, so casting will be required somewhere.
				///Now, I can determine the correct return type from the 'nesting' argument, since it keeps track of the depth of this digit, and I can also express that type at the point of call
				///So I just need to cast it correctly. I figured the most convenient way to cast was at this point.
				///</remarks>
				public override TExpected Apply<TExpected, TValue2>(int nesting, Func<TValue, TValue2> selector, Lineage lin) {
						switch (nesting) {
							<# for (var i = 1; i < 32; i++) {
	#>case <#=i #>:
									return (TExpected)(object)ApplyTo<<#=GetNestedTypeName(i) #>, TValue2>(nesting, selector, lin);
							<#
}
							#>
							default:
								throw ImplErrors.Invalid_execution_path("Finger trees shouldn't have digits more than 32 deep!");
						}
				}
			}
		}
	}
}
<#+

	string GetNestedTypeName(int n) {
		if (n == 1) return "Leaf<TValue2>";
		else return string.Format("FingerTree<TValue2>.FTree<{0}>.Digit", GetNestedTypeName(n - 1));
	}#>