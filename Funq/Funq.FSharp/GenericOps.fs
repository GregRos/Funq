module internal Funq.FSharp.GenSeq 
#nowarn "77"
open System
let inline  isEmpty o                     = (^s : (member IsEmpty : bool) o )
let inline  dropLast o                    = (^s : (member DropLast : unit -> 's) o)
let inline  dropFirst o                   = (^s : (member DropFirst : unit -> 's) o )
let inline  first o                       = (^s : (member First : 'a) o)
let inline  last o                        = (^s : (member Last : 'a) o)
let inline  length o                      = (^s : (member Length : int) o )
let inline update(i,v) o                  = (^s : (member Update : int * 'a -> 's) o, i, v)
let inline insert(i,v) o                  = (^s : (member Insert : int * 'a -> 's) o, i, v)
let inline remove i o                     = (^s : (member Remove : int -> 's) o, i)
let inline slice(i1, i2) o                = (^s : (member get_Item : int * int -> 's) o, i1, i2)
let inline map f o                        = (^s : (member Select : Func<'a,'b> -> 't) o ,toFunc1 f)
let inline filter f o                     = (^s : (member Where : Func<'a, bool> -> 's) o, toFunc1 f)
let inline collect f o                    = (^s : (member SelectMany : Func<'a, 'b seq> -> 't) o, toFunc1 f)
let inline iter f o                       = (^s : (member ForEach : Action<'a> -> unit) o, toAction f)
let inline iterWhile f o                  = (^s : (member ForEachWhile : Func<'a, bool> -> bool) o, toFunc1 f)
let inline iterBack f o                   = (^s : (member ForEachBack : Action<'a> -> unit) o, toAction f)
let inline iterBackWhile f o              = (^s : (member ForEachBackWhile : Func<'a, bool> -> bool) o, toFunc1 f)
let inline zip r l                        = (^s : (member Zip : 'b seq * Func<'a, 'b, 'a * 'b> -> 'r) l, r, toFunc2 (fun l r -> (l,r)))
let inline fold v f o                     = (^s : (member Aggregate : 'r * Func<'r, 'u, 'r> -> 'r) o, v, toFunc2 f)
let inline foldBack v f o                 = (^s : (member AggregateBack : 'r * Func<'r, 'u, 'r> -> 'r) o, v, toFunc2 f)
let inline choose (f : 'a -> 'b option) o = (^s : (member Select : Func<'a, Funq.Option<'b>> -> 't) o, (f >> toOption) |> toFunc1)
let inline tryFirst o                     = (^s : (member TryFirst : 'b Funq.Option) o) |> fromOption
let inline tryLast o                      = (^s : (member TryLast : 'b Funq.Option) o ) |> fromOption
let inline reduce f o                     = (^s : (member Reduce : Func<'a, 'a, 'a> -> 'a) o, f)
let inline reduceBack f o                 = (^s : (member ReduceBack : Func<'a, 'a, 'a> -> 'a) o, f)
let inline tryFind f o                    = (^s : (member Find : Func<'a, bool> -> 'a Funq.Option) o, toFunc1 f) |> fromOption
let inline tryFindIndex f o               = (^s : (member FindIndex : Func<'a, bool> -> int Funq.Option) o, toFunc1 f) |> fromOption
let inline pick f o                       = (^s : (member Pick : Func<'a, 'b Funq.Option> -> 'b Funq.Option) o, f >> toOption |> toFunc1) |> fromOption
let inline take n o                       = (^s : (member Take : int -> 's) o, n)
let inline takeWhile f o                  = (^s : (member TakeWhile : Func<'a, bool> -> 's) o, f |> toFunc1)
let inline skip n o                       = (^s : (member Skip : int -> 's) o, n) 
let inline skipWhile f o                  = (^s : (member SkipWhile : Func<'a, bool> -> 's) o, f |> toFunc1)
let inline exists f o                     = (^s : (member Any : Func<'a, bool> -> bool) o, f |> toFunc1)
let inline forAll f o                     = (^s : (member All : Func<'a, bool> -> bool) o, f |> toFunc1)
let inline count f o                      = (^s : (member Count : Func<'a, bool> -> int) o, f |> toFunc1)
let inline nth n o                        = (^s : (member get_Item : int -> 'a) o, n)
let inline scan r f o                     = (^s : (member Scan : 'r * Func<'r, 'a, 'r> -> 't) o, r, toFunc2 f)
let inline scanBack r f o                 = (^s : (member ScanBack : 'r * Func<'r, 'a, 'r> -> 't) o, r, toFunc2 f)
let inline addLast v o                    = (^s : (member AddLast : 'v -> 's) o, v)
let inline addFirst v o                   = (^s : (member AddFirst : 'v -> 's) o, v)
let inline addFirstList vs o              = (^s : (member AddFirstList : 's -> 's) o, vs)
let inline addLastList vs o               = (^s : (member AddLastList : 's -> 's) o, vs)
let inline addLastRange vs o              = (^s : (member AddLastRange : 'v seq -> 's) o, vs)
let inline addFirstRange vs o             = (^s : (member AddFirstRange : 'v seq -> 's) o, vs)
let inline concat r l                     = (^s : (member Concat : 's -> 's) l, r)
let inline insertRange i vs o             = (^s : (member InsertRange : int * 'a seq -> 's) o, i, vs)
let inline insertList i vs o              = (^s : (member InsertList : int * 's -> 's) o, i, vs)